{"posts":[{"title":"小草bot帮助文档","text":"小草bot的帮助文档 mai功能 以及神秘功能 1234/草绑 &lt;你的uid&gt; //用于绑定你的mai账号/草飞 &lt;倍数&gt; //获取神秘物品/草润 &lt;时间戳&gt; //用于自行脱离小黑屋/我要自闭15分钟 //字面意思（ 随机图片 目前可用的关键词如下 1234kagura来点峰哥来点小红grass OI竞赛有关功能 12cf //获取最近三场codeforces比赛nc //获取最近三场牛客比赛 杂项 1 To Do [ ]mai服务器状态查询 [ ]牢dust电脑开着吗（ [ ]…","link":"/2024/10/15/GrassBot%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"title":"P1226 【模板】快速幂","text":"比较简单，但是难理解，所以写篇题解 作为模板题，本该是秒切，但是还是花了较长时间才AC，还是题刷少了（咕咕咕） 废话不多说，直接上题 题面 题目描述 给你三个整数 a,b,pa,b,pa,b,p，求 ab mod pa^b \\bmod pabmodp。 输入格式 输入只有一行三个整数，分别代表 a,b,pa,b,pa,b,p。 输出格式 输出一行一个字符串 a^b mod p=s，其中 a,b,pa,b,pa,b,p 分别为题目给定的值， sss 为运算结果。 样例 #1 样例输入 #1 12 10 9 样例输出 #1 12^10 mod 9=7 提示 样例解释 210=10242^{10} = 1024210=1024，1024 mod 9=71024 \\bmod 9 = 71024mod9=7。 数据规模与约定 对于 100%100\\%100% 的数据，保证 0≤a,b&lt;2310\\le a,b &lt; 2^{31}0≤a,b&lt;231，a+b&gt;0a+b&gt;0a+b&gt;0，2≤p&lt;2312 \\leq p \\lt 2^{31}2≤p&lt;231。 首先把题上形式列出 ab=ac1∗20∗ac2∗21∗ac3∗22∗...∗acn∗2na^b=a^{c_1*2^0}*a^{c_2*2^1}*a^{c_3*2^2}*...*a^{c_n*2^n}ab=ac1​∗20∗ac2​∗21∗ac3​∗22∗...∗acn​∗2n 即 ab=ac1∗20+c2∗21+c3∗22+...+cn∗2na^b=a^{c_1*2^0+c_2*2^1+c_3*2^2+...+c_n*2^n}ab=ac1​∗20+c2​∗21+c3​∗22+...+cn​∗2n 是不是一头雾水awa 是就对了，因为我当时看各个题解的时候也是一样的orz 那么，我们怎么快速求出这个式子呢 首先把上面的式子扔一边，拿出我们的二进制 比如，设 a=11a=11a=11，那它的二进制就表示为101110111011 也表示为 a=11=23+21+20a=11=2^3+2^1+2^0a=11=23+21+20 快速幂中也存在类似的形式 再回头看看刚刚的那个式子，你有没有发现了什么地方形式是相似的 ab=ac1∗20+c2∗21+c3∗22+...+cn∗2na^b=a^{c_1*2^0+c_2*2^1+c_3*2^2+...+c_n*2^n}ab=ac1​∗20+c2​∗21+c3​∗22+...+cn​∗2n 还看不出来？emm qwq，那再看看这个（为方便理解暂时删去了常数c） 15=20+21+22+2315={2^0+2^1+2^2+2^3}15=20+21+22+23 b=20+21+22+...+2nb={2^0+2^1+2^2+...+2^n}b=20+21+22+...+2n 有点头绪了吧，那让我们来解决它 上面的式子可以化成 b=c1∗20+c2∗21+c3∗22+...+cn∗2nb={c_1*2^0+c_2*2^1+c_3*2^2+...+c_n*2^n}b=c1​∗20+c2​∗21+c3​∗22+...+cn​∗2n 其中的c为常数，1代表这一位存在 由上面我们对二进制形式的分析，我们可以发现，aba^bab的指数b可以用二进制表示 然后，再由 a=a∗aa=a*a a=a∗a a2=a∗aa^2=a*a a2=a∗a a4=a2∗a2a^4=a^2*a^2 a4=a2∗a2 a8=a4∗a4a^8=a^4*a^4 a8=a4∗a4 a16=a8∗a8a^{16}=a^8*a^8 a16=a8∗a8 ...... ... a2n+1=a2n∗a2na^{2^{n+1}}=a^{2^n}*a^{2^n} a2n+1=a2n∗a2n 欸！是不是就对上啦！ 我们暂时先将取模放在一边，先将代码写出来，后面再加入 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int fastpow_mod(int base,int level){ int bs = base;//1 int ans = 1 ; while(level&gt;0){ if(level&amp;1){ ans = ans*bs; } bs=bs*bs; level &gt;&gt;= 1; } return ans;}signed main(){ int a,b,q; cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; cout &lt;&lt; a &lt;&lt; '^' &lt;&lt; b &lt;&lt; &quot; mod &quot; &lt;&lt; q &lt;&lt; '=' &lt;&lt; fastpow_mod(a,b);} 如果对“>>=”与“&”等位运算有疑惑的可以看这里 此文只提供所需知识，如果有缺漏还请自行查阅资料 按位与运算符 1&amp;1=1 1&amp;0=0 0&amp;1=0 0&amp;0=0 右移运算符 比如11的二进制1011，在进行&gt;&gt;=1操作后，整体右移，变为101 101110111011 &gt;&gt;= 101(1)101(1)101(1)(此处1就没了) （已在代码中表明对应位置） 1.其中的bs在上文的式子中与a同位，负责在循环中作为每一位的那个aba^bab 2.ans负责在循环中作为ab1+b2+...+bna^{b_1+b_2+...+b_n}ab1​+b2​+...+bn​的累乘 3.level在上文的式子中与bbb的二进制表示同位，负责在循环中作为bbb的二进制表示，并用&amp;1判断该位是否存在 4.level &gt;&gt;= 1;负责将level整体右移一位，即判断下一位是否存在 接下来，我们加上取模 首先，我们要知道取模运算的分配律 (a+b)%c=(a%c+b%c)modc(a+b) \\% c=(a \\% c+b \\% c) mod c (a+b)%c=(a%c+b%c)modc (a−b)%c=(a%c−b%c)modc(a-b) \\% c=(a \\% c-b \\% c) mod c (a−b)%c=(a%c−b%c)modc (a∗b)%c=(a%c∗b%c)modc(a*b) \\% c=(a \\% c*b \\% c) mod c (a∗b)%c=(a%c∗b%c)modc 所以，我们可以将代码修改为 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int fastpow_mod(int base,int level,int num_mod){ int bs = base; int ans = 1 ; while(level&gt;0){ if(level&amp;1){ ans = (ans*bs)%num_mod; } bs=((bs%num_mod)*(bs%num_mod))%num_mod; level &gt;&gt;= 1; } return ans;}signed main(){ int a,b,q; cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; cout &lt;&lt; a &lt;&lt; '^' &lt;&lt; b &lt;&lt; &quot; mod &quot; &lt;&lt; q &lt;&lt; '=' &lt;&lt; fastpow_mod(a,b,q);} 到此，我们就完成了这道题。 第一次写文，若有不好还请见谅orz","link":"/2024/10/17/P1226%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"title":"Codeforces Round 983 (Div. 2) - C.Trinity","text":"前几天div2止步此题（又菜又爱打），不甘心，拜读题解多次，可算是理解了，记录一下。 先上题面 指路[http://codeforces.com/problemset/problem/2032/C] 题面 You are given an array aaa of nnn elements a1,a2,…,ana_1, a_2, \\ldots, a_na1​,a2​,…,an​. You can perform the following operation any number (possibly 000) of times: Choose two integers iii and jjj, where 1≤i,j≤n1 \\le i, j \\le n1≤i,j≤n, and assign ai:=aja_i := a_jai​:=aj​. Find the minimum number of operations required to make the array aaa satisfy the condition: For every pairwise distinct triplet of indices (x,y,z)(x, y, z)(x,y,z) (1≤x,y,z≤n1 \\le x, y, z \\le n1≤x,y,z≤n, x≠yx \\ne yx​=y, y≠zy \\ne zy​=z, x≠zx \\ne zx​=z), there exists a non-degenerate triangle with side lengths axa_xax​, aya_yay​ and aza_zaz​, i.e. ax+ay&gt;aza_x + a_y &gt; a_zax​+ay​&gt;az​, ay+az&gt;axa_y + a_z &gt; a_xay​+az​&gt;ax​ and az+ax&gt;aya_z + a_x &gt; a_yaz​+ax​&gt;ay​. Input Each test consists of multiple test cases. The first line contains a single integer ttt (1≤t≤1041 \\le t \\le 10^41≤t≤104) — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer nnn (3≤n≤2⋅1053 \\le n \\le 2 \\cdot 10^53≤n≤2⋅105) — the number of elements in the array aaa. The second line of each test case contains nnn integers a1,a2,…,ana_1, a_2, \\ldots, a_na1​,a2​,…,an​ (1≤ai≤1091 \\le a_i \\le 10^91≤ai​≤109) — the elements of the array aaa. It is guaranteed that the sum of nnn over all test cases does not exceed 2⋅1052 \\cdot 10^52⋅105. Output For each test case, output a single integer — the minimum number of operations required. Test case 12345678910//input471 2 3 4 5 6 731 3 234 5 3159 3 8 1 6 5 3 8 2 1 4 2 9 4 7 12345//output3108 Note In the first test case, one of the possible series of operations would be: Assign a1:=a4=4a_1 := a_4 = 4a1​:=a4​=4. The array will become [4,2,3,4,5,6,7][4, 2, 3, 4, 5, 6, 7][4,2,3,4,5,6,7]. Assign a2:=a5=5a_2 := a_5 = 5a2​:=a5​=5. The array will become [4,5,3,4,5,6,7][4, 5, 3, 4, 5, 6, 7][4,5,3,4,5,6,7]. Assign a7:=a1=4a_7 := a_1 = 4a7​:=a1​=4. The array will become [4,5,3,4,5,6,4][4, 5, 3, 4, 5, 6, 4][4,5,3,4,5,6,4]. It can be proven that any triplet of elements with pairwise distinct indices in the final array forms a non-degenerate triangle, and there is no possible answer using less than 333 operations. In the second test case, we can assign a1:=a2=3a_1 := a_2 = 3a1​:=a2​=3 to make the array a=[3,3,2]a = [3, 3, 2]a=[3,3,2]. In the third test case, since 333, 444 and 555 are valid side lengths of a triangle, we don’t need to perform any operation to the array. 前情提要 题目要求任意三个数都可以组成三角形，一开始想到的是将所有数据排序，然后取前面两个最小值，然后找最大满足三角形第三边的数，后面其他全部变成这个数，果不其然WA了（ 然后又倒着来了一遍也WA。以至于后面ccpc一路上也全是这题（ 现在看，当时其实距离AC只差一个结论的推广，何以见得？ 如下样例（已排序处理） 12 3 4 5 6 6 7 8 9 当我们取2，3为最小两边时，5以及后面的数据则全部需要进行操作，即总共需要操作6次。 1| 2 3 4 | 5 6 6 7 8 9 而当我们取3，4为最小两边时，7及之后的数据则需要进行操作，同时3之前的2也需要进行操作，才能满足我们的最小的要求，总计需要操作4次。 12 | 3 4 5 6 6 | 7 8 9 所以不同最小两边的选择，需要操作的数据量也不同，而我们的目标就是找到所框选的最小区间。 总结下来，我们要实现的步骤如下： 对数组进行排序 遍历数组，找到最小两边 计算并记录所框选区间需要操作的数据量 重复步骤2-3，直到遍历完数组 遍历完数组后，找到操作数据量最少的区间，并输出结果 而每次遍历所需操作数过多，需要优化时间复杂度，这时候我们就要用到二分，在步骤2中使用二分查找进一步降低时间复杂度 所以步骤为： 对数组进行排序 对数组使用二分查找，找到最小两边 计算并记录所框选区间需要操作的数据量 重复步骤2-3，直到遍历完数组 遍历完数组后，找到操作数据量最少的区间，并输出结果 代码如下： （因看过题解，所以写出来基本完全一致orz） 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed solve(){ int n; cin &gt;&gt; n; //初始化数组 vector&lt;int&gt;a(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } //从小到大进行排序 sort(a.begin(),a.end()); //初始化答案为最大值，即保证答案一定小于它（INF） int ans = 999999999; //遍历数组，寻找每一个区间的操作最小值 for (int i = 0; i &lt; n-1; i++) { //二分查找满足右侧边界的最大值 int p = lower_bound(a.begin(),a.end(), a[i] + a[i+1]) - a.begin(); //与当前最小值比较，取最小值 ans = min(ans, n-p+i); } cout &lt;&lt; ans &lt;&lt; endl;}signed main(){ int t; cin &gt;&gt; t; while(t--){ solve(); }} 至此，AC 后记 这道题其实不难，但是一开始的思路局限，导致后面WA且思维怠于拓展结论，最后还是看了题解才明白，所以还是练少了（ 看到这里了，希望有所帮助","link":"/2024/11/05/Codeforces%20Round%20983%20(Div.%202)%20-%20C.Trinity/"}],"tags":[{"name":"Grassbot","slug":"Grassbot","link":"/tags/Grassbot/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"}],"categories":[{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"算法刷题随笔","slug":"算法刷题随笔","link":"/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E9%9A%8F%E7%AC%94/"}],"pages":[]}